---
layout: post
title:  "Exoid"
date:   2016-08-19
---

### Exoid API Protocol - A REST Alternative for JSON

The [Exoid](https://github.com/Zorium/exoid) protocol is a simple batching rpc protocol, with uuid-based resource caching.
Requests are composed of a `path` and `body` (optional).
Unlike REST, there is no verb distinction (i.e. `GET` vs `POST`), instead naming convention is used (i.e. `user.getById` vs `user.updateById`).
Response resources (any object with an `id`) must use `uuid` strings. This allows for stateless object cache invalidation by requests.
E.g. I change a users profile photo, which changes __both__ the `user` and `photo` resource. We can respond with one explicitly (return the new user), and either update or invalidate the extra modified resource via `cache: [{path:'photo-uuid', result: {new photo}}]` (implicit, relying on uuid).
If a request body consists only of a uuid string (`{path: 'xxx', body: '-uuid-'}`), the local `cache` is used to resolve the request (if possible).

With this basic resource model we can overlay a streaming object interface for a true FRP object model (see client interface below).

```coffee
# Request - POST /exoid
{
  requests: [
    {path: 'users.getMe'}
    {path: 'users.getAll', body: {x: 'y'}}
  ]
}

# Response
{
  results: [
    {id: '2e6-uuid-3df9'}
    [{id: '2e6-uuid-3df9'}]
  ]
  errors: [null, null]
}

# Response with cache update
{
  results: [
    {id: '2e6-uuid-3df9'}
    [{id: '2e6-uuid-3df9'}]
  ]
  errors: [null, null]
  cache: [
    {path: '60f-uuid-4bdd', result: {id: '60f-uuid-4bdd'}} # cache
    {path: '974-uuid-a596'} # invalidate
  ]
}
```

### Server Interface

[Exoid-Router](https://github.com/Zorium/exoid-router) provides a wrapper for Express requests to simplify protocol implementation.

```coffee
# routes.coffee
router = require 'exoid-router'
UserCtrl = require './controllers/user'

routes = router
.on 'users.getById', UserCtrl.getById
.on 'users.updateById', UserCtrl.updateById

app.post '/exoid', routes.asMiddleware()
```

```coffee
# controllers/user.coffee
router = require 'exoid-router'
Joi = require 'joi'
User = require '../models/user'

class UserCtrl
  getById: (id, req) ->
    # req.user comes from auth middleware (not shown)
    unless req.user? and req.user.id is id
      router.throw status: 401, info: 'Unauthorized'

    User.getById id
    .then User.sanitize

  updateById: (body, req) ->
    {id, username} = body
    # Supports Joi schema assertion
    router.assert {id, username}, {
      id: Joi.string()
      username: Joi.string().min(2).max(20)
    }

    User.updateById(id, {username})
    .then -> User.getById(id)
    .then (user) ->
      # req.cache() provided by exoid-router
      req.cache user.id, user
      # alternatively return the user object instead of caching it
      return null
```

### Client Interface

The [Exoid client](https://github.com/Zorium/exoid) exposes two main methods, `stream()` and `call()`.
Both have the signature `<String>Path, <Any>Body`, except one returns a promise and the other returns an Rx Observable.
The Observable will update whenever the underlying resource changes (identified by uuid).
Thus when calling `updateById`, the returned modified object will propagate to all existing streams which contain that object.

```coffee
Exoid = require 'exoid'
request = require 'clay-request'

@exoid = new Exoid
  api: config.API_URL + '/exoid'
  fetch: request

@exoid.stream 'users.getById', id # -> Observable
@exoid.call 'users.updateById', {username: 'joe'} # -> Promise
```

### Real World Usage

For a sample server side implementation check out [Exoid Seed](https://github.com/Zorium/exoid-seed), and for client side check out [Zorium Seed](https://github.com/Zorium/zorium-seed).
To understand the power of the stream interface, here is an example [Zorium](https://github.com/Zorium/zorium) component.

```coffee
# components/hello_world.coffee
Button = require 'zorium-paper/button'
module.exports = class HelloWorld
  constructor: ({model}) ->
    @$increment = new Button({
      onclick: _.partial @increment, model
    })

    @state = z.state
      count: model.example.getCount() # exoid.stream()
      username: model.user.getMe().map ({username}) -> username #  exoid.stream()

  increment: (model) ->
    model.example.incrementCount() # exoid.call()
    .catch log.error

  render: =>
    {username, count} = @state.getValue()

    z '.z-hello-world',
      z '.username',
        "username: #{username}"
      z '.count',
        "count: #{count}"
      @$increment
```

```coffee
# models/example.coffee
module.exports = class Example
  constructor: ({@exoid}) -> null
  getCount: =>
    @exoid.stream('count.get').map ({count}) -> count

  incrementCount: =>
    @exoid.call 'count.inc'
```
